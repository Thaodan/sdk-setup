#!/bin/bash
#
# Copyright (C) 2013 - 2016 Jolla Ltd.
# Contact: David Greaves <david.greaves@jollamobile.com>
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
# - Redistributions of source code must retain the above copyright
#   notice, this list of conditions and the following disclaimer.
# - Redistributions in binary form must reproduce the above copyright
#   notice, this list of conditions and the following disclaimer in
#   the documentation and/or other materials provided with the
#   distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

synopsis() {
    cat <<EOF
usage: $ME [global-opts] <command> [command-opts]
       $ME --version
EOF
}

short_usage() {
    synopsis
    cat <<EOF

Try '$ME --help' for more information.
EOF
    # exit if any argument is given
    [[ -n "$1" ]] && exit 1
}

usage() {
    less --quit-if-one-screen <<EOF
$(synopsis)

Executes a subset of build commands in the context of an rpmbuild.
Typically called from QtCreator to perform qmake/make phases of a project.
Note that any other build steps in the .spec file will also be run.

<specfile> will be looked for in the current rpm/ dir. If there is more than
one it must be provided.  $ME is aware of spectacle and will update the spec
file if there is an obvious yaml file which is newer.

CWD is used as a base dir for installroot/ and RPMS/ to allow for
shadow builds.

If a file exists with '.changes' extension, otherwise matching the
spec file name, the effect will be the same as having a %changelog
section in the spec file.  If a file with '.changes.run' extension is
found instead, this file will be executed and its output treated as
the actual changelog.

COMMANDS
    installdeps
        Install the missing build-time dependencies as is done implicitly by
        the "prep", "build" and "qmake" commands but refresh the package cache
        first.
        Compatible global options: -s -t -p

    prep
        Run rpmbuild. Execute just the %prep section of the .spec file.
        Compatible global options: -n.

    apply [-R]
        Apply all patches defined in the .spec file to the source tree.
        -R    reverse apply patches (patch -R)

    build [-p|--doprep] [-d|--enable-debug] [-j <n>] [<rpmbuild-extra-args>]
        Run rpmbuild. Execute all sections of the .spec file except for %prep
        unless told otherwise.
        -p    run %prep phase as well
        -d    enable debug build
        -j <n> use only 'n' CPUs to build
        Compatible global options: -s -t -p -i -x -X -c -n

    qmake [<qmake-extra-args>]
        Run rpmbuild. Execute just the %build section of the .spec file,
        suppressing any "make" invocation figuring in that section.
        Compatible global options: -s -t -p -n

    make [<make-extra-args>]
        Run rpmbuild. Execute just the %build section of the .spec file,
        suppressing any "qmake" invocation figuring in that section.
        Compatible global options: -s -t -p

    install
        Run rpmbuild. Execute just the %install section of the .spec file.
        Compatible global options: -s -t -p

    rpm
        Run rpmbuild. Execute just the %install section of the .spec file, then
        build binary packages.
        Compatible global options: -s -t -p -i -x -X -c

    deploy --zypper|--pkcon|--rsync|--sdk
        Deploy build results to a device. This implies also the "install" step
        and except for the --rsync method it will include also the "rpm" step.
        Compatible global options: -s -t -p -d -i -f -x -X -c

    run [<command> [<args>]]
        Run the given command (on device if --device given).  Can be used for
        running gdb and a gdb server.
        Compatible global options: -s -t -p -d

GLOBAL OPTIONS
    -i, --increment
        Increment release number in .spec file

    -t, --target <name>
        Specify the sb2 target to use

    -d, --device <name>
        Specify the device

    -o, --outputdir <dir>
        Where to place produced RPM files. Defaults to ./RPMS directory.  With
        this option existing files in the output directory are preserved

    -p, --projectdir <dir>
        When running shadow build/deploy from another dir

    -s, --specfile <file>
        Specify the .spec file

    -f, --shared-folder <dir>
        The folder where QtCreator shares devices.xml and ssh keys this option
        is useful if deploy option is used outside of virtual machine

    -x, --fix-version[=<tag>]
        This option is implied when used inside a Git working tree (use -X to
        override). Within Application SDK it is only implied if the version
        recorded in the .spec file is exactly "0".
        Use the latest tag from the current git branch as package version or
        the given <tag>.  If the current HEAD, index or working tree differs
        from the tree denoted by the tag, a suffix composed from the current
        branch name, time stamp and a commit SHA1 will be added to the package
        version.  If git-state is not clean a git-stash will be created and its
        SHA1 will be used instead of HEAD.

    -X, --no-fix-version
        Override --fix-version option.

    -n, --no-deps
        Do not update target dependencies

    -c, --git-change-log[=<args>]
        Include change log generated from Git history with 'git-change-log'
        command, forwarding any <args>.  This option is not intended for
        regular use - create a script file named after the .spec file but with
        '.changes.run' extension to instruct $ME to generate changelog with
        'git-change-log <args>' instead.

EOF
}

notice() {
    echo "NOTICE: $*" >&2
}

fatal() {
    echo "Fatal: $*" >&2
    exit 1
}

# readarray is a bash >= 4.0 feature
if ! type readarray &>/dev/null; then
    readarray() {
        if ! [[ $# -eq 2 && $1 == -t && $(declare -p "$2" 2>/dev/null) == "declare -a "* ]]; then
            fatal "Internal error: readarray: unimplemented case"
        fi

        local line=
        eval $2=\(\)
        while IFS= read -r line; do
            eval $2=\(\${$2[@]:+\"\${$2[@]}\"} \"\$line\"\)
        done
    }
fi

git_() (
    # Cannot use the '-C' option - it requires newer Git.
    # Cannot use '--git-dir' + '--work-tree' options - they break at least git-stash.
    if [[ $OPT_PROJDIR ]]; then
        cd "$OPT_PROJDIR" || return
    fi
    # At least git-stash requires an explicitly set user identity. Setting environment
    # variables compared to passing options with '-c' works also for subprocesses invoked via
    # `git-submodule foreach`
    if inside_build_engine; then
        export GIT_AUTHOR_NAME='mersdk' GIT_AUTHOR_EMAIL='mersdk@mersdk'
        export GIT_COMMITTER_NAME='mersdk' GIT_COMMITTER_EMAIL='mersdk@mersdk'
    fi

    git "$@"
)

try_to_make_spec() { # Tries to create a missing spec
    [[ -f "$1" ]] && return # It's not missing
    local yaml="${1%.spec}.yaml"
    [[ -f "$yaml" ]] || return # No yaml
    ANSI_COLORS_DISABLED=1 specify -n -N "$yaml" || fatal "unable to convert yaml to spec"
}

try_to_make_spec_from_yaml() {
    # Tries to create a missing spec from a given yaml
    try_to_make_spec "${1%.yaml}.spec"
}

sanitize_changelog() {
    sed 's/%/%%/g'
}

try_to_make_changelog() {
    local changes_file=${OPT_SPEC%.spec}.changes
    local changes_run_file=${OPT_SPEC%.spec}.changes.run

    if [[ $OPT_GIT_CHANGE_LOG ]]; then
        notice "Auto generating changelog from Git history ..."
        echo "%changelog"
        git-change-log $OPT_GIT_CHANGE_LOG_ARGS |sanitize_changelog
    elif [[ -f $changes_file ]]; then
        notice "Appending changelog entries to spec ..."
        echo "%changelog"
        cat $changes_file |sanitize_changelog
    elif [[ -f $changes_run_file ]]; then
        notice "Generating changelog entries with $changes_run_file ..."
        local runner=
        # In build VM the shared filesystem is noexec
        if ! [[ -x $changes_run_file ]]; then
            if [[ $(head -c 3 <$changes_run_file |cat -v) == '#!/' ]]; then
                runner=$(sed -n '1s/^#!//p' $changes_run_file)
            else
                fatal "Not executable: $changes_run_file"
            fi
        fi
        echo "%changelog"
        $runner $changes_run_file |sanitize_changelog
        [[ ${PIPESTATUS[0]} -eq 0 ]] || fatal "unable to generate changelog entries"
    fi
}

ensure_spec_newer_than_yaml() {
    local yaml="${OPT_SPEC%.spec}.yaml"
    if [[ -f "$yaml" ]] && [[ "$yaml" -nt "$OPT_SPEC" ]]; then # -nt is newer than
        ANSI_COLORS_DISABLED=1 specify -n -N "$yaml" || fatal "unable to convert yaml to spec"
    fi

    # it's ok also not to have a yaml
}

verify_target_dependencies() {
    [[ $OPT_NO_DEPS ]] && return

    local deps=()
    readarray -t deps < <(sb2 -t "$OPT_TARGET" rpmspec --query --buildrequires "$OPT_SPEC" |sed 's/\s*$//')
    if [[ $deps ]]; then
        if inside_build_engine; then
            local oldpkgs=$(sb2 -t "$OPT_TARGET" -m sdk-install rpm -qa)
        fi
        sb2 -t "$OPT_TARGET" -m sdk-install -R zypper --quiet --non-interactive in "${deps[@]}"
        if inside_build_engine; then
            local newpkgs=$(sb2 -t "$OPT_TARGET" -m sdk-install rpm -qa)
            if [[ $newpkgs != $oldpkgs ]]; then
                sdk-manage target sync "$OPT_TARGET"
            fi
        fi
    fi
}

get_spec_tag() {
    rpmspec --query --srpm --queryformat="$1" "$OPT_SPEC"
}

fix_package_version() {
    local spec_file=$1

    local version_in_spec=$(sed -n 's/^Version:[[:space:]]*//p' "$spec_file")

    if [[ $OPT_NO_FIX_VERSION ]]; then
        return
    elif [[ ! $OPT_FIX_VERSION ]]; then
        # When used inside a build engine VM, fixing version is enabled implicitly only if the
        # version in spec file is exactly "0" - this is because there is no UI in Qt Creator
        # that would allow to override this.
        if inside_build_engine && [[ $version_in_spec != 0 ]]; then
            return
        fi
    fi

    if ! inside_git_worktree; then
        if [[ $OPT_FIX_VERSION || $version_in_spec == 0 ]]; then
            notice "Not inside a Git working tree, will not fix package version."
        fi
        return
    fi

    local tag
    if [[ $OPT_FIX_VERSION_HINT ]]; then
        tag=$OPT_FIX_VERSION_HINT
    else
        if ! tag=$(git_ describe --tags --abbrev=0 2>/dev/null); then
            notice "No tags describe the HEAD, will not fix package version."
            return
        fi
    fi

    local version=$tag
    version=${version#*/}   # allow tags to have a prefix to allow vendor marking
    version=${version#v}    # some people like to prefix versions with a v

    local stash=
    if ! stash=$(git_ stash create); then
        fatal "Cannot save state of Git working tree: git-stash failed."
    fi
    local head=${stash:-$(git_ rev-parse HEAD)}

    local modified_submodules=
    modified_submodules=$(
        describe_if_modified()
        {
            local stash=
            stash=$(git stash create) || return
            local head=${stash:-$(git rev-parse HEAD)}
            if [[ $head != $sha1 ]]; then
                local short=$(git rev-list --max-count=1 --abbrev-commit "$head")
                echo -n "+$name.$short"
            fi
        }
        git_ submodule --quiet foreach --recursive \
            "$(declare -f describe_if_modified); describe_if_modified")
    if [[ $? -ne 0 ]]; then
        fatal "Cannot save state of Git submodules: git-stash failed for some."
    fi

    if [[ $(git_ rev-parse "$tag^{}") != "$head" || $modified_submodules ]]; then
        local branch=$(git_ rev-parse --abbrev-ref HEAD)
        local timestamp=$(TZ=UTC date --date=@$(git_ log --max-count=1 --pretty=%ct "$head") +%Y%m%d%H%M%S)
        local sha1sum=$(git_ rev-list --max-count=1 --abbrev-commit "$head")
        version=$version+$branch.$timestamp.$sha1sum$modified_submodules
    fi

    version=${version//[^+_[:alnum:]]/.} # replace characters not allowed in the version field

    echo "Setting version: ${version}"
    sed -i "s,^Version:.*,Version: ${version}," "$spec_file"
}

# Helper to read XML
read_dom () {
    local IFS=\>
    read -d \< ENTITY CONTENT
    local RET=$?
    TAG_NAME=${ENTITY%% *}
    ATTRIBUTES=${ENTITY#* }
    return $RET
}

# This slurps the XML and converts tags like <subnet> to $device_subnet
# Also sets device_name and device_type from the attributes
get_device() {
    local FOUND_DEVICE=
    local IN_DEVICE=
    local maintag=
    while read_dom; do
        case $TAG_NAME in
            device )
                maintag=$TAG_NAME
                eval local $ATTRIBUTES
                if [[ "$name" == "$1" ]] ; then
                    FOUND_DEVICE=1
                    IN_DEVICE=1
                    device_name="$name"
                    device_type="$type"
                else
                    IN_DEVICE=
                fi
                ;;
            engine )
                maintag=$TAG_NAME
                eval local $ATTRIBUTES
                ;;
            mac|index|subnet|ip|sshkeypath )
                # Don't process and store nested tags if we're in
                # device with wrong name
                if [[ "$maintag" == "device" ]] && [[ $IN_DEVICE != 1 ]]; then
                    continue
                fi
                eval ${maintag}_$TAG_NAME=\"$CONTENT\"
                ;;
        esac
    done
    # Set this up as it's useful
    if [[ "$device_subnet" ]]; then
        device_ip="$device_subnet".$device_index
    fi
    if [[ "$FOUND_DEVICE" == 1 ]]; then return 0; else return 1; fi
}

rsync_as() {
    local user="$1";shift
    local key=$(get_shared_dir)/${device_sshkeypath}/$user
    [[ -f "$key" ]] || fatal "No key for user $user on $device_name given in devices.xml (rsync $key)"
    RSYNC_RSH="ssh -F /etc/ssh/ssh_config.sdk -l $user -i \"$key\"" rsync "$@"
}

ssh_as() {
    local user="$1";shift
    local key=$(get_shared_dir)/${device_sshkeypath}/$user
    [[ -f "$key" ]] || fatal "No key for user $user on $device_name given in devices.xml ($key)"
    ssh -F /etc/ssh/ssh_config.sdk -i "$key" -l $user $device_ip "$(quote "$@")"
}

cd_to_spec_setup_dir() {
    _basedir="$PWD"

    # avoid spawning another process for | cut -s -f2 -d '/'
    local setup_dir=$(grep -Po '%setup.*-n[[:space:]]+[^[:space:]]+' "$OPT_SPEC")
    # if setup_dir has '/' return the part after it
    setup_dir=${setup_dir/#*\//}
    # if it did not have a '/' then we got the original match => erase it
    setup_dir=${setup_dir/#%setup*/}

    if [[ -n "$setup_dir" ]]; then
    # in case we got a spec %{tag} out of this, try to expand it
    setup_dir=$(get_spec_tag "$setup_dir")
    cd "$setup_dir"
    fi
}

# handle release tags with format "x" or "x.y", where x and y are
# numbers, leave others untouched
#  get tag
#  check if it has x.y
#  if it is x.y get y and check if y is number
#  if y is number => increment
#  if it only is x check if x is number
#  if x is number => increment
#  else leave untouched
increment_build_number() {
    [[ $OPT_INC_BUILD_NUMBER -eq 0 ]] && return

    local release=$(get_spec_tag "%{release}")
    local x=$(echo $release | cut -f 1 -d .)
    local y=$(echo $release | cut -s -f 2 -d .)
    local z=$(echo $release | cut -s -f 3- -d .)

    # more than one dot found => don't touch
    [[ -n "$z" ]] && return

    if [[ -n "$y" ]]; then
        if [[ $y =~ ^-?[0-9]+$ ]]; then
            let new_release=$y+1
            echo "Incrementing release: $x.$y -> $x.$new_release"
            sed -i "s/^Release:.*/Release: $x.$new_release/" "$OPT_SPEC"
            return
        else
            # non-numeric after dot => don't touch
            return
        fi
    fi

    if [[ -n "$x" ]]; then
        if [[ $x =~ ^-?[0-9]+$ ]]; then
            let new_release=$x+1
            echo "Incrementing release: $x -> $new_release"
            sed -i "s/^Release:.*/Release: $new_release/" "$OPT_SPEC"
            return
        fi
    fi
}

quote() {
    [[ $# -gt 0 ]] && printf "%q " "$@" |sed 's/ $//'
}

rpm_quote() {
    quote "$@" |sed 's/\\/&&/g'
}

init_wrapper() {
    local wrapper=$1
    local extra_args=("${@:2}")

    mkdir -p "${wrapper%/*}"
    {
        cat <<'END'
#!/bin/bash
self=${0#$PWD/}
command=${0##*/}

path=${0%/*}
PATH=${PATH/$path:/}

real=$(which "$command")
if [[ ! $real || $real == "$0" ]]; then
    echo "$self: Cannot find real $command" >&2
    exit 1
fi

echo "$self: Executing real $command:" >&2

set -x

"$real" "$@" \
END
        quote "${extra_args[@]}"
        echo
    } >"$wrapper"
    chmod +x "$wrapper"
}

init_noop_wrapper() {
    local wrapper=$1

    mkdir -p "${wrapper%/*}"
    cat <<'END' >"$wrapper"
#!/bin/bash
self=${0#$PWD/}
command=${0##*/}
echo "$self: Ignoring $command" >&2
END
    chmod +x "$wrapper"
}

run_installdeps() {
    # Refresh repos before installing dependencies
    sb2 -t "$target" -m sdk-install -R zypper --non-interactive ref
    verify_target_dependencies
}

run_apply() (
    rpm_dir="$(dirname "$OPT_SPEC")"
    cd_to_spec_setup_dir
    reverse="cat"
    if [ "$APPLY_REVERSE" -eq 1 ]; then
        reverse="tac"
    fi
    for p in $(sed -e '/^%patch/!d' -e 's/^%patch\([0-9]*\).*/\1/' "$OPT_SPEC" | $reverse); do
        op="$(grep "^%patch${p}" "$OPT_SPEC" | awk '{print $2}')"
        patch_file="$(grep "^Patch$p:" "$OPT_SPEC" | awk '{print $2}')"
        if [ "$APPLY_REVERSE" -eq 1 ]; then
            echo "Reversing $patch_file" >&2
            patch -R $op < "$rpm_dir/$patch_file" >&2
        else
            echo "Applying $patch_file" >&2
            patch $op < "$rpm_dir/$patch_file" >&2
        fi
    done
)

run_build() {
    # intended to provide mb build behaviour
    verify_target_dependencies

    increment_build_number;
    local tmp_spec="$OPT_SPEC.$$"
    if [[ $BUILD_NOPREP ]]; then
        sed -e '/^%patch/d' "$OPT_SPEC" > "$tmp_spec"
    else
        cp "$OPT_SPEC" "$tmp_spec"
    fi

    try_to_make_changelog >> "$tmp_spec"

    # get rid of potential windows linefeeds
    sed -i "s/\x0D$//g" "$tmp_spec"

    fix_package_version "$tmp_spec"

    local build_tgt=$(sb2 -t $OPT_TARGET gcc -dumpmachine)
    build_tgt=${build_tgt%-gnueabi}
    (
        cd_to_spec_setup_dir;
        [[ $OPT_CLEAN_OUTPUTDIR ]] && rm -f "$OPT_OUTPUTDIR/"*.rpm;
        sb2 -t $OPT_TARGET rpmbuild --build-in-place --target=$build_tgt \
            "${BUILD_DEBUG[@]}" \
            --define "_smp_mflags -j$(rpm_quote "$BUILD_JOBS")" \
            --define "_rpmdir $OPT_OUTPUTDIR" \
            --define "_sourcedir $_basedir/rpm" \
            --define "_rpmfilename %%{name}-%%{version}-%%{release}.%%{arch}.rpm" \
            --buildroot="$buildroot" \
            "${BUILD_NOPREP[@]}" \
            -bb \
            "$tmp_spec" \
            "$@"
    )
    local rc=$?
    rm -f "$tmp_spec"
    return $rc
}

run_prep() {
    verify_target_dependencies

    increment_build_number;
    local tmp_spec="$OPT_SPEC.$$"
    # TODO maybe add toggle here for disabling patch applying?
    cp "$OPT_SPEC" "$tmp_spec"

    # get rid of potential windows linefeeds
    sed -i "s/\x0D$//g" "$tmp_spec"

    fix_package_version "$tmp_spec"

    local build_tgt=$(sb2 -t $OPT_TARGET gcc -dumpmachine)
    build_tgt=${build_tgt%-gnueabi}
    (
        cd_to_spec_setup_dir;
        [[ $OPT_CLEAN_OUTPUTDIR ]] && rm -f "$OPT_OUTPUTDIR/"*.rpm;
        sb2 -t $OPT_TARGET rpmbuild --build-in-place --target=$build_tgt \
            "${BUILD_DEBUG[@]}" \
            --define "_smp_mflags -j$BUILD_JOBS" \
            --define "_rpmdir $OPT_OUTPUTDIR" \
            --define "_sourcedir $_basedir/rpm" \
            --define "_rpmfilename %%{name}-%%{version}-%%{release}.%%{arch}.rpm" \
            --buildroot="$buildroot" \
            -bp --short-circuit \
            "$tmp_spec"
    )
    local rc=$?
    rm -f "$tmp_spec"
    return $rc
}

run_qmake() {
    if [[ "$OPT_SPEC" ]]; then
        local build_tgt=$(sb2 -t $OPT_TARGET gcc -dumpmachine)
        build_tgt=${build_tgt%-gnueabi}

        local tmp_spec="$OPT_SPEC.$$"
        cp -a "$OPT_SPEC" "$tmp_spec"

        # get rid of potential windows linefeeds
        sed -i "s/\x0D$//g" "$tmp_spec"

        fix_package_version "$tmp_spec"

        # This is a good time to verify the target dependencies as per mb
        verify_target_dependencies

        init_wrapper $STATEDIR/wrappers/qmake "$@"
        init_noop_wrapper $STATEDIR/wrappers/make

        (
            cd_to_spec_setup_dir;
            sb2 -t $OPT_TARGET env PATH="$STATEDIR/wrappers:$PATH" rpmbuild \
                --build-in-place --target=$build_tgt \
                --define "noecho 1" \
                -bc --short-circuit \
                "$tmp_spec"
        )
        local rc=$?
        rm -f "$tmp_spec"
        return $rc
    else
        sb2 -t $OPT_TARGET qmake "$@"
    fi
}

run_make() {
    if [[ "$OPT_SPEC" ]]; then

        local tmp_spec="$OPT_SPEC.$$"
        cp -a "$OPT_SPEC" "$tmp_spec"

        # get rid of potential windows linefeeds
        sed -i "s/\x0D$//g" "$tmp_spec"

        fix_package_version "$tmp_spec"

        local build_tgt=$(sb2 -t $OPT_TARGET gcc -dumpmachine)
        build_tgt=${build_tgt%-gnueabi}

        init_noop_wrapper $STATEDIR/wrappers/qmake
        init_wrapper $STATEDIR/wrappers/make "$@"

        (
            cd_to_spec_setup_dir;
            sb2 -t $OPT_TARGET env PATH="$STATEDIR/wrappers:$PATH" rpmbuild \
                --build-in-place --target=$build_tgt \
                --define "noecho 1" \
                -bc --short-circuit \
                "$tmp_spec"
        )
        local rc=$?
        rm -f "$tmp_spec"
        return $rc
    else
        sb2 -t $OPT_TARGET make "$@"
    fi
}

run_install() {
    local build_tgt=$(sb2 -t $OPT_TARGET gcc -dumpmachine)
    build_tgt=${build_tgt%-gnueabi}

    local tmp_spec="$OPT_SPEC.$$"
    cp -a "$OPT_SPEC" "$tmp_spec"

    # get rid of potential windows linefeeds
    sed -i "s/\x0D$//g" "$tmp_spec"

    fix_package_version "$tmp_spec"

    # Install to buildroot which should be rsync'ed to /opt/sdk/$package on device
    (
        cd_to_spec_setup_dir;
        sb2 -t $OPT_TARGET rpmbuild --build-in-place --target=$build_tgt \
            --define "noecho 1" \
            --define "_sourcedir $_basedir/rpm" \
            --define "_skip_install_processing 1" \
            --buildroot="$buildroot" \
            -bi --short-circuit --nocheck \
            "$tmp_spec"
    )
    local rc=$?
    rm -f "$tmp_spec"
    return $rc
}

run_rpm() {
    local build_tgt=$(sb2 -t $OPT_TARGET gcc -dumpmachine)
    build_tgt=${build_tgt%-gnueabi}

    local tmp_spec="$OPT_SPEC.$$"
    cp -a "$OPT_SPEC" "$tmp_spec"

    try_to_make_changelog >> "$tmp_spec"

    # get rid of potential windows linefeeds
    sed -i "s/\x0D$//g" "$tmp_spec"

    fix_package_version "$tmp_spec"

    (
        increment_build_number;
        cd_to_spec_setup_dir;
        [[ $OPT_CLEAN_OUTPUTDIR ]] && rm -f "$OPT_OUTPUTDIR/"*.rpm;
        sb2 -t $OPT_TARGET rpmbuild --build-in-place --target=$build_tgt \
            --define "noecho 1" \
            --define "_rpmdir $OPT_OUTPUTDIR" \
            --define "_sourcedir $_basedir/rpm" \
            --define "_rpmfilename %%{name}-%%{version}-%%{release}.%%{arch}.rpm" \
            --buildroot="$buildroot" \
            -bb --noprep --nobuildstage --noclean \
            "$tmp_spec"
    )
    local rc=$?
    rm -f "$tmp_spec"
    return $rc
}

run_deploy() {
    [[ "$device_type" ]] || fatal "deploy must have a valid --device"
    local fail_text="deploy must use one of --pkcon, --rsync , --sdk or --zypper"
    [[ -z ${1:-} ]] && fatal $fail_text

    local retcode=0

    while [[ $1 ]]; do
        case "$1" in
            "--sdk" | "--pkcon" )
                local method;
                if [[ "$1" == "--sdk" ]]; then
                    method="sdk-deploy-rpm"
                else
                    method="pkcon --plain --noninteractive install-local"
                fi
                shift
                run_rpm
                [[ $? -ne 0 ]] && return 1
                rpms=$(find $OPT_OUTPUTDIR -name '*.rpm' -a ! -name '*-debug*.rpm')
                rsync_as $deviceuser -av ${rpms} $device_ip:/home/$deviceuser/RPMS/
                [[ $? -ne 0 ]] && return 1
                device_rpms=$(sed "s,^$OPT_OUTPUTDIR/,RPMS/," <<<"$rpms")
                ssh_as $deviceuser $method ${device_rpms}
                retcode=$?
                ssh_as $deviceuser rm -f ${device_rpms}
                ;;
            "--zypper" ) shift
                run_rpm
                [[ $? -ne 0 ]] && return 1
                rpms=$(find $OPT_OUTPUTDIR -name '*.rpm' -a ! -name '*-debug*.rpm')
                rsync_as root -av ${rpms} $device_ip:/root/RPMS/
                [[ $? -ne 0 ]] && return 1
                device_rpms=$(sed "s,^$OPT_OUTPUTDIR/,RPMS/," <<<"$rpms")
                ssh_as root zypper --non-interactive --quiet in -f ${device_rpms}
                retcode=$?
                ssh_as root rm -f ${device_rpms}
                ;;
            "--rsync" ) shift
                run_install
                [[ $? -ne 0 ]] && return 1
                name=$(get_spec_tag "%{name}")
                rsync_as $deviceuser -av ${buildroot}/. $device_ip:/opt/sdk/$name
                retcode=$?
                ;;
            *)
                fatal $fail_text ;;
        esac
    done

    [[ $retcode -eq 0 ]] || { echo "Deploy failed"; return 1; }
}

get_shared_dir() {
    echo "$OPT_SHARED_DIR"
}

inside_build_engine() [[ -f /etc/mer-sdk-vbox ]]
inside_git_worktree() { git_ status &>/dev/null; }

# this is same as basename $0
ME=${0/#*\//}

# option variables
OPT_SPEC=
OPT_TARGET=
OPT_DEVICE=
OPT_OUTPUTDIR=$(readlink -f ./RPMS)
OPT_CLEAN_OUTPUTDIR=1
OPT_PKGDIR="./rpm"
OPT_PROJDIR=
OPT_NEEDSPEC=
OPT_FIX_VERSION=
OPT_FIX_VERSION_HINT=
OPT_NO_FIX_VERSION=
OPT_GIT_CHANGE_LOG=
OPT_GIT_CHANGE_LOG_ARGS=
OPT_SHARED_DIR=/etc/mersdk/share
OPT_INC_BUILD_NUMBER=0
OPT_NO_DEPS=
deviceuser=nemo

STATEDIR=$PWD/.mb2

# Virtualbox environment will install in this hardcoded location
if inside_build_engine; then
    buildroot=/home/deploy/installroot
else
    buildroot="$PWD/installroot"
fi

################################################################################
if [[ $1 != --self-test ]]; then  ###  M A I N  EXECUTION BEGINS HERE  #########
################################################################################

while [[ "$1" ]]; do
    # only set variables in this loop
    case "$1" in
        "-t" | "--target") shift
            OPT_TARGET="$1"; shift
            ;;
        "-f" | "--shared-folder") shift
            OPT_SHARED_DIR="$1"; shift
            ;;
        "-d" | "--device") shift
            OPT_DEVICE="$1"; shift
            ;;
        "-o" | "--outputdir") shift
            OPT_OUTPUTDIR="$1"; shift
            [[ -d "$OPT_OUTPUTDIR" ]] || fatal "'$OPT_OUTPUTDIR' is not a directory"
            OPT_CLEAN_OUTPUTDIR=
            ;;
        "-p" | "--projectdir") shift
            OPT_PROJDIR="$1"; shift
            OPT_PKGDIR="$OPT_PROJDIR"/rpm
            [[ -d "$OPT_PROJDIR" ]] || fatal "'$OPT_PROJDIR' is not a directory"
            ;;
        "-s" | "--specfile" ) shift
            OPT_SPEC="$1"; shift
            ;;
        "-i" | "--increment" ) shift
            OPT_INC_BUILD_NUMBER=1
            ;;
        "-P" | "--pedantic" )
            notice "The '$1' option is deprecated and does nothing currently"
            shift
            ;;
        "-x" | "--fix-version" ) shift
            OPT_FIX_VERSION=1
            OPT_FIX_VERSION_HINT=
            OPT_NO_FIX_VERSION=
            ;;
        "-x="* | "--fix-version="* )
            OPT_FIX_VERSION=1
            OPT_FIX_VERSION_HINT=${1#*=}
            OPT_NO_FIX_VERSION=
            shift
            ;;
        "-X" | "--no-fix-version" ) shift
            OPT_FIX_VERSION=
            OPT_FIX_VERSION_HINT=
            OPT_NO_FIX_VERSION=1
            ;;
        "-n" | "--no-deps") shift
            OPT_NO_DEPS=1
            ;;
        "-c" | "--git-change-log" ) shift
            OPT_GIT_CHANGE_LOG=1
            ;;
        "-c="* | "--git-change-log="* )
            OPT_GIT_CHANGE_LOG=1
            OPT_GIT_CHANGE_LOG_ARGS="${1#*=}"
            shift
            ;;
        "-m" | "--submodule" )
            notice "The '$1' option is deprecated and does nothing currently"
            shift 2
            ;;
        install | rpm | deploy | build | installdeps | apply | prep )
            OPT_NEEDSPEC=1;
            break
            ;;
        qmake | make | run | ssh )
            break
            ;;
        --version )
            echo "$ME, version VERSION_FROM_SPEC"
            exit 0
            ;;
        --help )
            usage
            exit 0
            ;;
        *)
            short_usage quit
            ;;
    esac
done

if [[ -n "$OPT_SPEC" ]]; then
    try_to_make_spec "$OPT_SPEC"
    [[ -f "$OPT_SPEC" ]] || fatal "'$OPT_SPEC' doesn't exist (and could not be made from a yaml)"
fi

if [[ -n "$OPT_DEVICE" ]]; then
    [[ -f $(get_shared_dir)/devices.xml ]] || fatal "Unable to open $(get_shared_dir)/devices.xml"
    get_device "$OPT_DEVICE" < $(get_shared_dir)/devices.xml || fatal "'$OPT_DEVICE' not found in devices.xml"
fi

if [[ ! "$OPT_TARGET" ]]; then
    if [[ -f ~/.scratchbox2/config ]]; then
        . ~/.scratchbox2/config
        OPT_TARGET=$DEFAULT_TARGET
    fi
    [[ "$OPT_TARGET" ]] || fatal "You must specify an sb2 target or have a default configured"
fi

[[ -d ~/.scratchbox2/$OPT_TARGET ]] || fatal "$OPT_TARGET is an invalid sb2 target"

if [[ $OPT_FIX_VERSION_HINT && ! $(git_ tag --list "$OPT_FIX_VERSION_HINT") ]]; then
    fatal "'$OPT_FIX_VERSION_HINT' no such Git tag"
fi

case "$1" in
    qmake | make | install | installdeps | rpm | deploy | prep )
        cmd=run_$1
        shift
        ;;
    apply )
        cmd=run_$1; shift
        APPLY_REVERSE=0
        while [[ "$1" ]]; do
            case "$1" in
                -R) shift
                    APPLY_REVERSE=1 ;;
                *)
                    short_usage quit
                    ;;
            esac
        done
        ;;
    build )
        cmd=run_$1; shift
        BUILD_DEBUG=(--define "debug_package %{nil}")
        BUILD_JOBS=
        BUILD_NOPREP=(--noprep)
        while [[ "$1" ]]; do
            case "$1" in
                -d|--enable-debug) shift
                    BUILD_DEBUG=() ;;
                -j*)
                    # support giving -j with and without space between
                    # it and the 'n'
                    if [[ ${#1} -gt 2 ]]; then
                        BUILD_JOBS=${1:2}; shift
                    else
                        [[ -z "$2" ]] && short_usage quit
                        BUILD_JOBS="$2"; shift 2;
                    fi
                    ;;
                -p|--doprep) shift
                    BUILD_NOPREP=()
                    ;;
                *)
                    break
                    ;;
            esac
        done
        [[ $BUILD_JOBS ]] || BUILD_JOBS=$(getconf _NPROCESSORS_ONLN)
        ;;
    run | ssh )
        if [[ $1 == ssh ]]; then
            notice "The 'ssh' command is deprecated. Use 'run' instead."
        fi
        shift
        if [[ "$OPT_DEVICE" ]]; then
            cmd="ssh_as $deviceuser"
        else
            cmd=""
        fi
        ;;
    *)
        short_usage quit
        ;;
esac

# spec rules are complex:
#  a .spec is required for some but not all operations
#  if -s is given then
#    if it does not exist then specify tries to make it
#    if it exists it will be used
#  if there is a rpm/*.spec then that is used
#  if there is a rpm/*.yaml then a spec is made and used

if [[ ! "$OPT_SPEC" ]]; then
    # set nullglob on so that the shell glob expansions will return
    # empty if files are not found
    shopt -s nullglob
    spec_files=("$OPT_PKGDIR"/*.spec)
    numspec=${#spec_files[@]}
    if [[ $numspec -gt 1 ]]; then
        [[ $OPT_NEEDSPEC ]] && fatal "Too many spec files - please use -s to identify which one to use"
        echo "Too many spec files - not using any. Use -s to identify a specific one"
        # OPT_SPEC is not set
    fi

    if [[ $numspec -eq 0 ]]; then
        # No spec, try to find a yaml
        yaml_files=("$OPT_PKGDIR"/*.yaml)
        numyaml=${#yaml_files[@]}
        if [[ $numyaml -eq 1 ]]; then
            theyaml=("$OPT_PKGDIR"/*.yaml)
            try_to_make_spec_from_yaml "${theyaml[0]}"
            spec_files=("$OPT_PKGDIR"/*.spec)
            numspec=${#spec_files[@]}
        else
            [[ $OPT_NEEDSPEC ]] && fatal "No spec file found in '$OPT_PKGDIR/' and couldn't make one from a yaml #1"
        fi
    fi

    if [[ $numspec -eq 1 ]]; then
        thespec=("$OPT_PKGDIR"/*.spec)
        OPT_SPEC="${thespec[0]}"
    else
        # this is because we did try_to_make_spec_from_yaml and failed
        [[ $OPT_NEEDSPEC ]] && fatal "No spec file found in '$OPT_PKGDIR/' and couldn't make one from a yaml #2"
    fi

    # unset nullglob so that any further globbing works normally
    shopt -u nullglob
fi

# Now if there is a spec given, make sure it is up-to-date
if [[ "$OPT_SPEC" ]]; then
    # turn 'OPT_SPEC' into an absolute path
    OPT_SPEC=$(readlink -f "$OPT_SPEC")
    ensure_spec_newer_than_yaml
fi

rm -rf "$STATEDIR/wrappers"

$cmd "$@"

##############################################################################
exit; fi ###  S E L F - T E S T  EXECUTION BEGINS HERE #######################
##############################################################################

set -o nounset

SELF=$(readlink -f "$0")

: ${MB2_SELF_TEST_VERBOSE:=}
: ${MB2_SELF_TEST_TS:=}

temp=$(mktemp -d) || exit
trap "rm -rf '$temp'" EXIT
cd "$temp" || exit

mkdir stubs || exit
STUBS_DIR=$(readlink -f stubs)
export PATH="$STUBS_DIR:$PATH"

################################################################################
# Test utils

tc_num=0
tc_failed_num=0

set_up_ts() {
    local ts=$1
    TS_NAME=$2

    if [[ $MB2_SELF_TEST_TS && $TS_NAME != "$MB2_SELF_TEST_TS" ]]; then
        return
    fi

    ${ts}_ts_set_up "${@:3}"
    if [[ $? -ne 0 ]]; then
        fatal "Test suite set-up failed: $ts"
    fi
}

tear_down_ts() {
    local ts=$1

    if [[ $MB2_SELF_TEST_TS && $TS_NAME != "$MB2_SELF_TEST_TS" ]]; then
        return
    fi

    ${ts}_ts_tear_down
    if [[ $? -ne 0 ]]; then
        fatal "Test suite tear-down failed: $ts"
    fi
    TS_NAME=
}

KNOWN_ISSUES=()
KNOWN_ISSUE() {
    KNOWN_ISSUES=(${KNOWN_ISSUES[@]:+"${KNOWN_ISSUES[@]}"} "$1")
}

run_tc() {
    local tc=$1
    TC_NAME=$2
    local args=("${@:3}")

    if [[ $MB2_SELF_TEST_TS && ${TS_NAME:-} != "$MB2_SELF_TEST_TS" ]]; then
        KNOWN_ISSUES=()
        return
    fi

    let tc_num++
    echo "*** Executing test case: ${TS_NAME:+$TS_NAME - }$TC_NAME"

    local known_issue
    for known_issue in ${KNOWN_ISSUES[@]:+"${KNOWN_ISSUES[@]}"}; do
        echo "    Known issue: $known_issue"
    done
    KNOWN_ISSUES=()

    local stderr=
    { stderr=$(${tc}_tc ${args[@]:+"${args[@]}"} 3>&1 1>&2 2>&3 3>&-); } 2>&1
    local rc=$?

    if [[ $rc -ne 0 ]]; then
        let tc_failed_num++
    fi

    if [[ $rc -ne 0 || $MB2_SELF_TEST_VERBOSE ]]; then
        cat <<END
  ** Stderr     ** [[
$stderr
]]
END
    fi

    if [[ $(type -t ${tc}_tc_tear_down) == function ]]; then
        ${tc}_tc_tear_down
        if [[ $? -ne 0 ]]; then
            fatal "Test case tear-down failed: $tc"
        fi
    fi

    return $rc
}

arg_pass_stub_create() {
    while [[ ${1:-} ]]; do
        local stub=$STUBS_DIR/$1
        local results=$STUBS_DIR/$1.args

        touch "$results" || return
        cat >"$stub" <<END || return
#!/bin/bash
echo "stub invoked: \$0 \$(printf "%q " "\$@")" >&2
{ [[ \$# -ne 0 ]] && printf "%q\\n" "\$@"; } >"$results"
exit 0
END
        chmod +x "$stub" || return
        shift
    done
}

arg_pass_stub_remove() {
    while [[ ${1:-} ]]; do
        local stub=$STUBS_DIR/$1
        local results=$STUBS_DIR/$1.args
        rm -f "$stub" || return
        rm -f "$results" || return
        shift
    done
}

arg_pass_stub_results() {
    local results=$STUBS_DIR/$1.args
    [[ -e $results ]] && cat "$results"
}

arg_pass_stub_clear() {
    while [[ ${1:-} ]]; do
        local results=$STUBS_DIR/$1.args
        rm -f "$results" || return
        shift
    done
}

expect_args() {
    [[ $# -ne 0 ]] && printf "%q\n" "$@" || true
}

sb2_stub() {
    echo "stub invoked: $0 $(printf "%q " "$@")" >&2

    local args=("$@")
    bad_args() {
        echo "stub $0: unexpected arguments: $(printf "%q " "${args[@]}")" >&2
    }

    if ! [[ $1 == -t && $3 != -* ]]; then
        bad_args
        return 1
    fi

    shift 2

    env=(env)
    if [[ $1 == env ]]; then
        shift
        while [[ $1 == -* || $1 =~ ^[[:alnum:]_]+= ]]; do
            env+=("$1")
            shift
        done
    fi

    case $1 in
        gcc)
            case $2 in
                -dumpmachine)
                    echo "i486-meego-linux"
                    ;;
                *)
                    bad_args
                    return 1
                    ;;
            esac
            ;;
        rpmbuild)
            # rpmbuild writes some progress messages to stdout
            exec "${env[@]}" "$@" >&2
            ;;
        rpmspec)
            exec "${env[@]}" "$@"
            ;;
        *)
            bad_args
            return 1
            ;;
    esac
}

sb2_stub_create() {
    cat >"$STUBS_DIR/sb2" <<END || return
#!/bin/bash
$(declare -f sb2_stub)
sb2_stub "\$@"
END
    chmod +x "$STUBS_DIR/sb2" || return
}

sb2_stub_remove() {
    rm -f "$STUBS_DIR/sb2" || return
}

DEFAULT_TARGET=$(. ~/.scratchbox2/config; echo "$DEFAULT_TARGET")
DEFAULT_JOBS=$(getconf _NPROCESSORS_ONLN)

if inside_build_engine; then
    DEFAULT_DEVICE="Sailfish OS Emulator"
else
    echo "Note: Skipping test cases involving device connection - not inside a Sailfish OS build engine" >&2
    DEFAULT_DEVICE=
fi

################################################################################
# Test the rpm_quote function

rpm_quote_tc() {
    arg_pass_stub_create make || return

    # Create an minimal spec file
    mkdir rpm || return
    cat >rpm/test.spec <<END || return
Name: test
Version: 1.0
Release: 0
Summary: Test
License: BSD

# This would normally come from the environment
%{!?make:%define make make}

%description
Test

%build
%make "x  y"
END

    rpmbuild -bc --short-circuit --noprep --build-in-place --define "_sourcedir $(readlink -f rpm)" rpm/test.spec \
        --define "make make $(rpm_quote "a b" "c  d" e f)" >&2 || return
    local rc=0 expected= actual= diff=
    expected=$(expect_args "a b" "c  d" e f "x  y")
    actual=$(arg_pass_stub_results make) || return
    if ! diff=$(diff <(cat <<<"$expected") <(cat <<<"$actual")); then
        rc=1
        cat <<END
Test case failed: $TC_NAME
  ** Mismatch   ** [[
$diff
]]
  ** Expected   ** [[
$expected
]]
  ** Actual     ** [[
$actual
]]
END
    fi

    arg_pass_stub_remove make || return
    rm -f rpm/test.spec || return
    rmdir rpm || return

    return $rc
}

run_tc rpm_quote "Test RPM macro escaping"

################################################################################
# Test sb2 argument passing

sb2_arg_pass_ts_set_up() {
    arg_pass_stub_create sb2 || return

    # Create an empty spec file
    mkdir rpm || return
    : >rpm/test.spec || return
}

sb2_arg_pass_ts_tear_down() {
    arg_pass_stub_remove sb2 || return
    rm -f rpm/test.spec || return
    rmdir rpm || return
}

sb2_arg_pass_tc() {
    local expected=$1
    local args=("${@:2}")

    arg_pass_stub_clear sb2 || return
    "$SELF" "${args[@]}" || return
    local actual_raw= actual= diff=
    actual_raw=$(arg_pass_stub_results sb2) || return
    actual=$(sed -e 's,/tmp\.[^/]\+,/@TMPDIR@,' \
                 -e "s,/home/deploy,/tmp/@TMPDIR@," \
                 -e 's,/test\.spec\.[^/]\+,/@TEST_SPEC@,' <<<"$actual_raw")
    if ! diff=$(diff <(cat <<<"$expected") <(cat <<<"$actual")); then
        cat <<END
Test case failed: $TC_NAME
  ** Command    ** $ME $(quote "${args[@]}")
  ** Mismatch   ** [[
$diff
]]
  ** Expected   ** [[
$expected
]]
  ** Actual     ** [[
$actual
]]
  ** Actual RAW ** [[
$actual_raw
]]
END
        return 1
    fi
}

set_up_ts sb2_arg_pass "Passing arguments to sb2"

KNOWN_ISSUE "Does not disable debug by default (ignores --enable-debug)"
KNOWN_ISSUE "Passes -j without argument"
KNOWN_ISSUE "Silently ignores extra arguments"
run_tc sb2_arg_pass "prep" \
    "$(expect_args \
        -t "$DEFAULT_TARGET" rpmbuild --build-in-place --target= \
        --define '_smp_mflags -j' \
        --define '_rpmdir /tmp/@TMPDIR@/RPMS' \
        --define '_sourcedir /tmp/@TMPDIR@/rpm' \
        --define '_rpmfilename %%{name}-%%{version}-%%{release}.%%{arch}.rpm' \
        --buildroot=/tmp/@TMPDIR@/installroot \
        -bp --short-circuit \
        /tmp/@TMPDIR@/rpm/@TEST_SPEC@)" \
    prep "a b" "c  d" e f

run_tc sb2_arg_pass "build" \
    "$(expect_args \
        -t "$DEFAULT_TARGET" rpmbuild --build-in-place --target= \
        --define 'debug_package %{nil}' \
        --define "_smp_mflags -j$(rpm_quote "bad  1")" \
        --define '_rpmdir /tmp/@TMPDIR@/RPMS' \
        --define '_sourcedir /tmp/@TMPDIR@/rpm' \
        --define '_rpmfilename %%{name}-%%{version}-%%{release}.%%{arch}.rpm' \
        --buildroot=/tmp/@TMPDIR@/installroot \
        -bb \
        /tmp/@TMPDIR@/rpm/@TEST_SPEC@ \
        "a b" "c  d" e f)" \
    build --doprep -j "bad  1" "a b" "c  d" e f

run_tc sb2_arg_pass "build with debug" \
    "$(expect_args \
        -t "$DEFAULT_TARGET" rpmbuild --build-in-place --target= \
        --define "_smp_mflags -j$(rpm_quote "bad  1")" \
        --define '_rpmdir /tmp/@TMPDIR@/RPMS' \
        --define '_sourcedir /tmp/@TMPDIR@/rpm' \
        --define '_rpmfilename %%{name}-%%{version}-%%{release}.%%{arch}.rpm' \
        --buildroot=/tmp/@TMPDIR@/installroot \
        -bb \
        /tmp/@TMPDIR@/rpm/@TEST_SPEC@ \
        "a b" "c  d" e f)" \
    build --doprep --enable-debug -j "bad  1" "a b" "c  d" e f

run_tc sb2_arg_pass "qmake" \
    "$(expect_args \
        -t "$DEFAULT_TARGET" env PATH="/tmp/@TMPDIR@/.mb2/wrappers:$PATH" rpmbuild \
        --build-in-place --target= \
        --define 'noecho 1' \
        -bc --short-circuit \
        /tmp/@TMPDIR@/rpm/@TEST_SPEC@)" \
    qmake "a b" "c  d" e f

run_tc sb2_arg_pass "make" \
    "$(expect_args \
        -t "$DEFAULT_TARGET" env PATH="/tmp/@TMPDIR@/.mb2/wrappers:$PATH" rpmbuild \
        --build-in-place --target= \
        --define 'noecho 1' \
        -bc --short-circuit \
        /tmp/@TMPDIR@/rpm/@TEST_SPEC@)" \
    make "a b" "c  d" e f

KNOWN_ISSUE "Silently ignores extra arguments"
run_tc sb2_arg_pass "install" \
    "$(expect_args \
        -t "$DEFAULT_TARGET" rpmbuild --build-in-place --target= \
        --define 'noecho 1' \
        --define '_sourcedir /tmp/@TMPDIR@/rpm' \
        --define '_skip_install_processing 1' \
        --buildroot='/tmp/@TMPDIR@/installroot' \
        -bi --short-circuit --nocheck \
        /tmp/@TMPDIR@/rpm/@TEST_SPEC@)" \
    install "a b" "c  d" e f

KNOWN_ISSUE "Silently ignores extra arguments"
run_tc sb2_arg_pass "rpm" \
    "$(expect_args \
        -t "$DEFAULT_TARGET" rpmbuild --build-in-place --target= \
        --define 'noecho 1' \
        --define '_rpmdir /tmp/@TMPDIR@/RPMS' \
        --define '_sourcedir /tmp/@TMPDIR@/rpm' \
        --define '_rpmfilename %%{name}-%%{version}-%%{release}.%%{arch}.rpm' \
        --buildroot='/tmp/@TMPDIR@/installroot' \
        -bb --noprep --nobuildstage --noclean \
        /tmp/@TMPDIR@/rpm/@TEST_SPEC@)" \
    rpm "a b" "c  d" e f

tear_down_ts sb2_arg_pass

################################################################################
# Test arguments passing to commands invoked by rpmbuild

rpmbuild_arg_pass_ts_set_up() {
    RPMBUILD_STUBS=(qmake make)
    arg_pass_stub_create "${RPMBUILD_STUBS[@]}"

    sb2_stub_create || return

    # Create a minimal spec file
    mkdir rpm || return
    cat >rpm/test.spec <<END || return
Name:       test

# These would normally come from the environment
%{!?qmake:%define qmake qmake}
%{!?qmake5:%define qmake5 qmake}

# This is to not require meego-rpm-config installed for self-test execution
%global __os_install_post %{nil}

Summary:    Test
Version:    0.1
Release:    1
Group:      Qt/Qt
License:    LICENSE
URL:        http://example.org/
Source0:    %{name}-%{version}.tar.bz2

%description
Test

%prep
%setup -q -n %{name}-%{version}

%build
%qmake5
make %{?_smp_mflags}

%install
mkdir -p %{buildroot}

%files
%defattr(-,root,root,-)
END
}

rpmbuild_arg_pass_ts_tear_down() {
    arg_pass_stub_remove "${RPMBUILD_STUBS[@]}" || return
    sb2_stub_remove || return
    rm -f rpm/test.spec || return
    rmdir rpm || return
}

rpmbuild_arg_pass_tc() {
    local all_expected=("${@:1:${#RPMBUILD_STUBS[*]}}")
    local args=("${@:1+${#RPMBUILD_STUBS[*]}}")

    local rc=0

    arg_pass_stub_clear "${RPMBUILD_STUBS[@]}"
    "$SELF" "${args[@]}" || return
    local i=
    for ((i=0; i<${#RPMBUILD_STUBS[@]}; i++)); do
        local stub= expected= actual= diff=
        stub=${RPMBUILD_STUBS[i]}
        expected=${all_expected[i]}
        actual=$(arg_pass_stub_results "$stub")
        if ! diff=$(diff <(cat <<<"$expected") <(cat <<<"$actual")); then
            rc=1
            cat <<END
Test case failed: $TC_NAME/$i
  ** Command    ** $ME $(printf "%q " "${args[@]}")
  ** Failed for ** $stub
  ** Mismatch   ** [[
$diff
]]
  ** Expected   ** [[
$expected
]]
  ** Actual     ** [[
$actual
]]
END
        fi
    done

    return $rc
}

set_up_ts rpmbuild_arg_pass "Passing arguments to commands invoked by rpmbuild"

run_tc rpmbuild_arg_pass "build" \
    "$(expect_args )" \
    "$(expect_args -j"$DEFAULT_JOBS")" \
    build

run_tc rpmbuild_arg_pass "qmake" \
    "$(expect_args "a b" "c  d" e f)" \
    "$(expect_args )" \
    qmake "a b" "c  d" e f

if [[ $DEFAULT_JOBS -ne 1 ]]; then
    run_tc rpmbuild_arg_pass "make" \
        "$(expect_args )" \
        "$(expect_args -j"$DEFAULT_JOBS" "a b" "c  d" e f)" \
        make "a b" "c  d" e f
else
    run_tc rpmbuild_arg_pass "make" \
        "$(expect_args )" \
        "$(expect_args "a b" "c  d" e f)" \
        make "a b" "c  d" e f
fi

tear_down_ts rpmbuild_arg_pass

################################################################################
# Test arguments passing to commands invoked using run|ssh subcommand

ssh_arg_pass_ts_set_up() {
    :
}

ssh_arg_pass_ts_tear_down() {
    :
}

ssh_arg_pass_tc() {
    local expected=$1
    local args=("${@:2}")

    local actual= diff=
    actual=$("$SELF" "${args[@]}")
    if ! diff=$(diff <(cat <<<"$expected") <(cat <<<"$actual")); then
        cat <<END
Test case failed: $TC_NAME
  ** Command    ** $ME $(quote "${args[@]}")
  ** Mismatch   ** [[
$diff
]]
  ** Expected   ** [[
$expected
]]
  ** Actual     ** [[
$actual
]]
END
        return 1
    fi
}

set_up_ts ssh_arg_pass "Passing arguments using run|ssh subcommand"

run_tc ssh_arg_pass "local - just spaces" \
    "$(printf '%q ' 'a b' 'c  d' e f)" \
    run printf '%q ' 'a b' 'c  d' e f

run_tc ssh_arg_pass "local - spaces and newlines" \
    "$(printf '%q'$'\n' 'echo b' 'c  d' e f)" \
    run printf '%q'$'\n' 'echo b' 'c  d' e f

run_tc ssh_arg_pass "local - spaces and backslashes" \
    "$(printf '%q\n' 'a\ b' 'c  d' e f)" \
    run printf '%q\n' 'a\ b' 'c  d' e f

if [[ $DEFAULT_DEVICE ]]; then
    run_tc ssh_arg_pass "remote - just spaces" \
        "$(printf '%q ' 'a b' 'c  d' e f)" \
        --device "$DEFAULT_DEVICE" run printf '%q ' 'a b' 'c  d' e f

    run_tc ssh_arg_pass "remote - spaces and newlines" \
        "$(printf '%q'$'\n' 'echo b' 'c  d' e f)" \
        --device "$DEFAULT_DEVICE" run printf '%q'$'\n' 'echo b' 'c  d' e f

    run_tc ssh_arg_pass "remote - spaces and backslashes" \
        "$(printf '%q\n' 'a\ b' 'c  d' e f)" \
        --device "$DEFAULT_DEVICE" run printf '%q\n' 'a\ b' 'c  d' e f
fi

tear_down_ts ssh_arg_pass

################################################################################
# Test --fix-version behavior

fix_version_ts_set_up() {
    COMMITS_U=()
    COMMITS_D=()

    get_commit() {
        eval echo \${COMMITS_${1:0:1}[${1:1}]} |grep .
    }

    local i= commit= tag_name= tag_object=

    git init . --quiet || return
    git config user.email "john@doe.com" || return
    git config user.name "John Doe" || return

    git checkout -b upstream --quiet
    for ((i=0; i<=30; i++)); do
        printf "U%02d\n" "$i" > U
        git add U || return
        date="@$(TZ=UTC date --date="2000-01-01 00:00:00 UTC +$i days" +%s) +0000"
        GIT_AUTHOR_DATE=$date GIT_COMMITTER_DATE=$date \
            git commit --message "$(<U)" --quiet || return
        commit=$(git rev-list --max-count=1 --abbrev-commit HEAD) || return
        COMMITS_U=(${COMMITS_U[*]:-} $commit)
    done

    git checkout -b downstream "${COMMITS_U[10]}" --quiet || return
    for ((i=0; i<=20; i++)); do
        if [[ $i -eq 10 ]]; then
            git merge --no-commit "${COMMITS_U[20]}" --quiet 2>/dev/null || return
        fi
        printf "D%02d\n" "$i" > D
        git add D || return
        date="@$(TZ=UTC date --date="2000-01-01 00:00:00 UTC +$((i+10)) days +12 hours" +%s) +0000"
        GIT_AUTHOR_DATE=$date GIT_COMMITTER_DATE=$date \
            git commit --message "$(<D)" --quiet || return
        commit=$(git rev-list --max-count=1 --abbrev-commit HEAD) || return
        COMMITS_D=(${COMMITS_D[*]:-} $commit)
    done

    while [[ ${1:-} ]]; do
        case $1 in
            --tag)
                tag_name=$2
                tag_object=$(get_commit $3) || return
                git tag "$tag_name" "$tag_object" || return
                shift 2
                ;;
            --tag-a)
                tag_name=$2
                tag_object=$(get_commit $3) || return
                tag_annotation="$3"
                git tag -a -m "$tag_annotation" "$tag_name" "$tag_object" || return
                shift 2
                ;;
            *)
                return 1
                ;;
        esac
        shift
    done
}

fix_version_ts_tear_down() {
    unset COMMITS_U COMMITS_D
    unset -f get_commit
    rm -rf .git || return
    rm -f U D dirty || return
}

fix_version_tc() {
    local dirty=$1 head=$2 expected_raw=$3 hint=${4:-}

    head=$(get_commit "$head") || return

    git reset --hard --quiet || return
    git checkout -B downstream "$head" --quiet || return
    if [[ $dirty == dirty ]]; then
        echo dirty >> D
    fi

    local version_file=version
    local last_stash_file=last_stash

    echo "Version:" > $version_file

    (
        git() (
            echo "stub invoked: git" >&2
            if [[ $1 == stash && $2 == create ]]; then
                date="@$(TZ=UTC date --date="2000-12-31 18:00:00 UTC" +%s) +0000"
                GIT_AUTHOR_DATE=$date GIT_COMMITTER_DATE=$date \
                    command git stash create |tee $last_stash_file
            else
                command git "$@"
            fi
        )

        OPT_FIX_VERSION=1
        OPT_FIX_VERSION_HINT=$hint
        OPT_NO_FIX_VERSION=
        fix_package_version $version_file >&2
    ) || return

    local actual=$(sed 's/^Version: //' $version_file)

    local stash_sha1=
    if [[ -e $last_stash_file ]]; then
        stash_sha1=$(git rev-list --max-count=1 --abbrev-commit "$(<$last_stash_file)")
    fi

    local expected=$expected_raw i=
    for ((i=0; i<=30; i++)); do
        expected=${expected//@U$i@/${COMMITS_U[$i]}}
    done
    for ((i=0; i<=20; i++)); do
        expected=${expected//@D$i@/${COMMITS_D[$i]}}
    done
    expected=${expected//@STASH@/${stash_sha1:-<none>}}

    if [[ $actual != "$expected" ]]; then
        cat <<END
Test case failed: $TC_NAME
  ** Arguments    ** $(printf "%q " "$@")
  ** Expected     ** '$expected'
  ** Actual       ** '$actual'
  ** Expected RAW ** '$expected_raw'
  ** Git-status   ** [[
$(git status)
]]
  ** Git-log      ** [[
$(git log --graph --decorate --pretty=fuller --all ${stash_sha1:-})
]]
END
        return 1
    fi
}

# Works with Git history like this
#
# U00---...---U10---U11---...---U20---U21---...---U30 <-- upstream
#               \                 \
#                D00---D01---...---D10---D11---...---D20 <-- downstream
#
# Upstream commit dates are 2000-01-01 + <num> days 00:00 UTC, downstream commit dates are
# 2000-01-01 + <num+10> days 12:00 UTC, stashes are 2000-12-31 18:00 UTC.

set_up_ts fix_version "Test --fix-version behavior" \
    --tag v0.1 U5 \
    --tag v0.2 U10 \
    --tag v0.3 U15 \
    --tag v0.4 U20 \
    --tag v0.5 U25 \
    --tag mer/v0.2+git1 D5 \
    --tag mer/v0.4+git1 D11 \
    --tag-a mer/v0.4+git2 D15 \
    --tag mer/v0.4+git3 D20

run_tc fix_version "on tag, clean D5"               clean D5  0.2+git1
run_tc fix_version "ahead tag, clean D7"            clean D7  0.2+git1+downstream.2000''01''18''12''00''00.@D7@
run_tc fix_version "ahead tag, dirty D7"            dirty D7  0.2+git1+downstream.2000''12''31''18''00''00.@STASH@
run_tc fix_version "ahead upstream tag, clean D10"  clean D10 0.4+downstream.2000''01''21''12''00''00.@D10@
run_tc fix_version "on tag, clean D11"              clean D11 0.4+git1
run_tc fix_version "on tag, dirty D11"              dirty D11 0.4+git1+downstream.2000''12''31''18''00''00.@STASH@
run_tc fix_version "ahead tag, clean D12"           clean D12 0.4+git1+downstream.2000''01''23''12''00''00.@D12@
run_tc fix_version "ahead tag, dirty D12"           dirty D12 0.4+git1+downstream.2000''12''31''18''00''00.@STASH@
run_tc fix_version "on annotated, clean D15"        clean D15 0.4+git2
run_tc fix_version "ahead annotated, clean D16"     clean D16 0.4+git2+downstream.2000''01''27''12''00''00.@D16@
run_tc fix_version "ahead annotated, dirty D16"     dirty D16 0.4+git2+downstream.2000''12''31''18''00''00.@STASH@
run_tc fix_version "on tag, clean D15 + hint"       clean D15 0.4+git1+downstream.2000''01''26''12''00''00.@D15@    mer/v0.4+git1
run_tc fix_version "on tag, dirty D15 + hint"       dirty D15 0.4+git1+downstream.2000''12''31''18''00''00.@STASH@  mer/v0.4+git1
run_tc fix_version "ahead tag, clean D16 + hint"    clean D16 0.4+git1+downstream.2000''01''27''12''00''00.@D16@    mer/v0.4+git1
run_tc fix_version "ahead tag, dirty D16 + hint"    dirty D16 0.4+git1+downstream.2000''12''31''18''00''00.@STASH@  mer/v0.4+git1

tear_down_ts fix_version

################################################################################
# Test the readarray behavior - simplified version implemented as a shell
# function for compatibility with older BASH

readarray_tc() {
    local expected=('  abc *  def  ' '  g  h  i  ')
    local actual=()
    echo "Note: readarray is a $(type -t readarray)" >&2
    readarray -t actual < <(printf "%s\n" "${expected[@]}")
    if ! (
        [[ ${#expected[*]} -eq ${#actual[*]} ]] || exit
        for ((i=0; i<${#expected[*]}; i++)); do
            [[ ${actual[$i]} == "${expected[$i]}" ]] || exit
        done
        ); then
        cat <<END
Test case failed: $TC_NAME
  ** Expected   ** [[
$(declare -p expected)
]]
  ** Actual     ** [[
$(declare -p actual)
]]
END
        return 1
    fi
}

run_tc readarray "Test readarray behavior"

################################################################################
# Test build phases separation

rpmbuild_phases_ts_set_up() {
    RPMBUILD_STUBS=(my_setup qmake make my_install my_check)
    arg_pass_stub_create "${RPMBUILD_STUBS[@]}"

    sb2_stub_create || return

    # Create a minimal spec file
    mkdir rpm || return
    cat >rpm/test.spec <<END || return
Name:       test

# These would normally come from the environment
%{!?qmake:%define qmake qmake}
%{!?qmake5:%define qmake5 qmake}

# This is to not require meego-rpm-config installed for self-test execution
%global __os_install_post %{nil}

Summary:    Test
Version:    0.1
Release:    1
Group:      Qt/Qt
License:    LICENSE
URL:        http://example.org/
Source0:    %{name}-%{version}.tar.bz2

%description
Test

%prep
my_setup

%build
%qmake5
make %{?_smp_mflags}

%install
mkdir -p %{buildroot}
my_install

# Verifies that --noclean is used
touch %{buildroot}/foo

%check
my_check

%files
%defattr(-,root,root,-)
/foo
END
}

rpmbuild_phases_ts_tear_down() {
    arg_pass_stub_remove "${RPMBUILD_STUBS[@]}" || return
    sb2_stub_remove || return
    rm -f rpm/test.spec || return
    rmdir rpm || return
    rm -f RPMS/test-0.1-1.i486.rpm || return
    ! [[ -d RPMS ]] || rmdir RPMS || return
    rm -f "$buildroot/foo" || return
}

rpmbuild_phases_tc() {
    local expected=$1
    local args=("${@:2}")

    arg_pass_stub_clear "${RPMBUILD_STUBS[@]}" || return
    rm -f RPMS/test-0.1-1.i486.rpm || return

    "$SELF" "${args[@]}" || return

    local actual=
    if arg_pass_stub_results my_setup &>/dev/null; then
        actual="+prep"
    else
        actual="-prep"
    fi

    if arg_pass_stub_results qmake &>/dev/null; then
        actual="$actual +qmake"
    else
        actual="$actual -qmake"
    fi

    if arg_pass_stub_results make &>/dev/null; then
        actual="$actual +make"
    else
        actual="$actual -make"
    fi

    if arg_pass_stub_results my_install &>/dev/null; then
        actual="$actual +install"
    else
        actual="$actual -install"
    fi

    if arg_pass_stub_results my_check &>/dev/null; then
        actual="$actual +check"
    else
        actual="$actual -check"
    fi

    if [[ -e RPMS/test-0.1-1.i486.rpm ]]; then
        if rpm -q --requires -p RPMS/test-0.1-1.i486.rpm |grep -q '^rpmlib(ShortCircuited)'; then
            actual="$actual +rpm (short-circuited)"
        else
            actual="$actual +rpm"
        fi
    else
        actual="$actual -rpm"
    fi

    if [[ $actual != "$expected" ]]; then
        cat <<END
Test case failed: $TC_NAME
  ** Command    ** $ME $(printf "%q " "${args[@]}")
  ** Expected   ** $expected
  ** Actual     ** $actual
END
        return 1
    fi

    return 0
}

set_up_ts rpmbuild_phases "Separating build phases"

run_tc rpmbuild_phases "prep" \
    "+prep -qmake -make -install -check -rpm" prep
run_tc rpmbuild_phases "build" \
    "-prep +qmake +make +install +check +rpm" build
run_tc rpmbuild_phases "build --doprep" \
    "+prep +qmake +make +install +check +rpm" build --doprep
run_tc rpmbuild_phases "qmake" \
    "-prep +qmake -make -install -check -rpm" qmake
run_tc rpmbuild_phases "make" \
    "-prep -qmake +make -install -check -rpm" make
run_tc rpmbuild_phases "install" \
    "-prep -qmake -make +install -check -rpm" install
run_tc rpmbuild_phases "rpm" \
    "-prep -qmake -make +install +check +rpm" rpm

tear_down_ts rpmbuild_phases


################################################################################

if [[ $tc_failed_num -eq 0 ]]; then
    echo "*** All $tc_num tests passed"
else
    echo "*** $tc_failed_num out of $tc_num failed"
fi

# For Emacs:
# Local Variables:
# indent-tabs-mode:nil
# tab-width:4
# mode: sh
# End:
# For VIM:
# vim:set softtabstop=4 shiftwidth=4 tabstop=4 expandtab:
