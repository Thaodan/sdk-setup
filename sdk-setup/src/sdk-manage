#!/bin/bash
#
# This is a helper script for the Mer SDK to manage sb2 target and
# toolchain installation

set -o nounset

# Make sure normal users can use any dirs we make
umask 022

usage() {
    cat >&2 <<EOF
    usage (keep the arguments order):
           $0 --toolchain --list
           $0 --toolchain --install <arch>
           $0 --toolchain --remove <arch>

           $0 --target --list
           $0 --target --upgradable <name>
           $0 --target --install <name> <toolchain> <url>
           $0 --target --remove  <name>
           $0 --target --refresh {--all | <name>...}
           $0 --target --update <name>
           $0 --target --sync <name>
           $0 --target --import <name>
           $0 --target --register --user <user> --password <password> {--all | <name>...}

           $0 --devel --list <target> [<search string>]
           $0 --devel --install <target> <devel package list>
           $0 --devel --remove <target> <devel package list>

           $0 --sdk --version
           $0 --sdk --refresh
           $0 --sdk --upgradable
           $0 --sdk --upgrade
           $0 --sdk --status
           $0 --sdk --register --user <user> --password <password>

           $0 --refresh-all

           $0 --register-all --user <user> --password <password>

           $0 --version

       This is the Mer SDK VM manager
       For information see https://wiki.merproject.org/wiki/Platform_SDK_on_VirtualBox
       It is primarily intended for use by the SDK web interface.


EOF
}

if [[ $EUID -eq 0 ]]; then
    echo >&2 "WARNING: Invoking $0 as root is deprecated."
    if [[ -n ${SUDO_USER:-} ]]; then
        exec sudo -i -u $SUDO_USER $0 "$@"
        echo >&2 "sudo as '$SUDO_USER' failed"
        exit 1
    else
        echo >&2 "Cannot determine Mer SDK user. Invoke $0 as non-root to fix this."
        exit 1
    fi
fi

################################################################'
# Common utilities

print_array() {
    local array=("$@")
    declare -p array |sed 's/^[^=]*=//'
}

# Unpack result of `print_array` to variables passed as second and following args
unpack() {
    (eval local -a array=$1) 2>/dev/null || return
    eval local -a array=$1
    shift
    local i=0
    while [[ $# -gt 0 ]]; do
        eval $1=\${array[i++]}
        shift
    done
}

# Downloads file at ${url} into ${tmp_dir} using ${local_file_hint} as file name, unless ${url}
# points to a local file already, in which case the file is to be used directly.
#
# On success prints array with following items:
#  - local file path
#  - non-empty if the file was actually downloaded
#
# Returns non-zero on failure.
download() {
    local url=$1 tmp_dir=$2 local_file_hint=$3

    local local_file= downloaded=

    url=${url#file://}

    if ! [[ $url =~ ^(http|ftp)s?:// ]]; then
        local_file=$(readlink -f "$url") || return
        print_array "$local_file" "$downloaded"
        return
    fi

    local_file=$tmp_dir/$local_file_hint
    local orig_downloaded_file=$tmp_dir/${url##*/}
    local md5file="$orig_downloaded_file.md5sum"
    local md5sum_failed=

    local suceeded=
    download_cleanup() (
        trap 'echo cleaning up...' INT TERM HUP
        rm -f "$md5file"
        if [[ ! $succeeded ]]; then
            rm -f "$orig_downloaded_file"
            rm -f "$local_file"
        fi
    )
    trap 'download_cleanup; trap - RETURN' RETURN
    trap 'return 1' INT TERM HUP

    echo >&2 "Downloading '${url##*/}'"
    curl "$url" -o "$orig_downloaded_file"
    curl_status=$?

    if [[ $curl_status -eq 0 ]] ; then
        # check if md5sum file exists
        if curl --output /dev/null --silent --head --fail "$url.md5sum"; then
            # md5sum exists, let's check it
            curl --silent "$url.md5sum" > "$md5file"
            if ! (cd "$tmp_dir" && md5sum --status -c "$md5file"); then
                echo >&2 "ERROR: md5sum check failed for file '$orig_downloaded_file'!"
                md5sum_failed=1
            else
                echo >&2 "INFO: md5sum matches - download ok"
            fi
        else
            echo >&2 "WARNING: No md5sum file found - can not verify file integrity."
        fi
    fi

    if [[ $curl_status -ne 0 || ! -f $orig_downloaded_file || $md5sum_failed ||
        $(stat -c %s "$orig_downloaded_file") -lt 10000 ]]; then
        echo >&2 "Download failed!"
        return 1
    fi

    if ! [[ $orig_downloaded_file -ef $local_file ]]; then
        mv -f "$orig_downloaded_file" "$local_file" || return
    fi

    downloaded=1

    print_array "$local_file" "$downloaded"

    succeeded=1
}

################################################################'
# toolchain

# Our toolchains are available through patterns-sailfish-sb2-* meta-packages

get_toolchains() {
    zypper --quiet --no-refresh --non-interactive search "patterns-sailfish-sb2-*" | \
	grep patterns-sailfish-sb2 |grep -v sb2-common | while IFS='| ' read installed pkg dummy; do
	echo "${pkg},${installed}"
    done
    return ${PIPESTATUS[0]}
}

ensure_installed() {
    get_toolchains |grep -q -F --line-regexp "$1,i"
}

ensure_installable() {
    get_toolchains |grep -q -F --line-regexp "$1,"
}

install_toolchain() {
    local pkg=$1
    if ! ensure_installable "$pkg"; then
        echo >&2 "Toolchain '$pkg' doesn't exist or is already installed - can not install."
        return 2
    fi

    sudo zypper --quiet --non-interactive install -t pattern "$pkg"
}

remove_toolchain() {
    local pkg=$1
    if ! ensure_installed "$pkg"; then
        echo >&2 "Toolchain '$pkg' is not installed - can not remove."
        return 2
    fi

    sudo zypper --quiet --no-refresh --non-interactive remove -t pattern "$pkg"
}

manage_toolchains() {
    if ! [[ ${1:-} ]]; then
        usage
        return 1
    fi

    case $1 in
	--list )
	    get_toolchains
	    ;;
	--install ) shift
	    install_toolchain "$@"
	    ;;
	--remove ) shift
	    remove_toolchain "$@"
	    ;;
	* )
            echo >&2 "unrecognized option '$1'"
            usage
            return 1
	    ;;
    esac
}

################################################################'
# Devel packages

# Our devel packages are available through zypper as -devel packages

assert_target_and_setup() {
    local target=$1
    assert_target_name_valid "$target" || return
    if ! [[ -f $SBOX2DIR/$target/sb2.config ]]; then
        echo >&2 "Target '$target' is not a valid Scratchbox2 target"
        return 1
    fi

    if ! check_target_visible "$target"; then
        echo >&2 "Target '$target' is not accessible"
        return 1
    fi
}

t_zypper() {
    local target=$1
    shift
    sb2 -t "$target" -m sdk-install -R zypper --quiet "$@"
}

get_develpkgs() {
    local target=$1 search=$2
    # do not include sourcepackages to the list (-t package -t pattern)
    t_zypper "$target" --non-interactive --no-refresh search -t package -t pattern -- ${search:+"$search"} 2>&1 | \
	sed '0,/---------/d' | while IFS='| ' read installed pkg dummy; do
	echo "${pkg},${installed}"
    done
    return ${PIPESTATUS[0]}
}

manage_develpkgs() {
    if ! [[ {$1:-} ]]; then
        usage
        return 1
    fi

    case $1 in
	--list ) shift
            local target=${1:-} search=${2:-}
            assert_target_and_setup "$target" || return
            get_develpkgs "$target" "$search"
	    ;;
	--install ) shift
            local target=${1:-}
            assert_target_and_setup "$target" || return
            shift
            t_zypper "$target" --non-interactive --no-refresh install "$@" || return
            [[ $INSIDE_VBOX ]] && synchronise_target "$target"
	    ;;
	--remove ) shift
            local target=${1:-}
            assert_target_and_setup "$target" || return
            shift
            t_zypper "$target" --non-interactive --no-refresh remove "$@" || return
            [[ $INSIDE_VBOX ]] && synchronise_target "$target"
	    ;;
	* )
            echo >&2 "unrecognized option '$1'"
            usage
            return 1
	    ;;
    esac
}

################################################################
# Targets

t_register() {
    local target=$1 username=$2 password=$3

    local domain=
    domain=$(sb2 -t "$target" sdk-register -d) || return
    if [[ $domain != jolla ]]; then
        echo >&2 "Registration not needed for target '$target' (domain: ${domain:-empty})"
        return 0
    fi

    echo >&2 -n "$target: "
    sb2 -t "$target" -m sdk-install -R sdk-register -u "$username" -p "$password"
}

check_target_visible() (
    local target=$1
    set +u
    . $SBOX2DIR/$target/sb2.config
    test -d "$SBOX_TARGET_ROOT"
)

get_targets() {
    echo $(sb2-config -f 2>&1)
}

assert_target_name_valid() {
    if [[ ! ${1:-} ]]; then
      echo >&2 "Target name missing."
      return 1
    fi

    if ! [[ $1 =~ ^[-[:alnum:]_.]*$ ]]; then
        echo >&2 "Target name '$1' is not a valid Scratchbox2 target name."
        return 1
    fi
}

synchronise_target() {
    local target=$1
    # This is now a minimal set of files to sync
    if ! [[ -d $MER_TARGETS/$target ]]; then
        echo >&2 "No target called '$target'"
        return 1
    fi
    echo >&2 "Synchronising target to host"
    # The filter=". -" means to read filters from stdin (the <<EOF)
    rsync -a --no-devices --no-specials \
          --delete --ignore-errors \
	  --prune-empty-dirs  --copy-links \
	  --filter=". -" \
          "$MER_TARGETS/$target/." "$HOST_TARGETS/$target/." <<EOF || return
# Ensure all dirs are copied (--prune-empty-dirs will clean up)
+ */
# We want this for QtCreator to determine the architecture
+ /usr/lib/libQt*Core.so
# Don't need any other .so files
- *.so
# All the import, include and qt* shares
+ /usr/lib/qt*/imports**
# Qt5 qml imports are here
+ /usr/lib/qt5/qml**
+ /usr/include**
+ /usr/share/qt**
+ /usr/lib/pkgconfig**
+ /usr/share/pkgconfig**
# and nothing else
- *
EOF
    # We need /usr/bin/stopCreatorSegfaulting for Creator's happiness
    mkdir -p "$HOST_TARGETS/$target/usr/bin" || return
    touch "$HOST_TARGETS/$target/usr/bin/stopCreatorSegfaulting" || return
    # For Qt5, QtCreator needs to see this dir or it thinks Qt version is not properly installed
    mkdir -p "$HOST_TARGETS/$target/usr/lib/qt5/bin/" || return

    echo >&2 "Sync completed"
}

import_target() {
    local target=$1
    # This could be minimised in the future if sf is not fixed
    # Ignore errors as we sometimes have dangling symlinks and
    # still want to keep clean
    if ! [[ -d $HOST_TARGETS/$target ]]; then
        echo >&2 "No host target called '$target'"
        return 1
    fi
    rsync -a --no-devices --no-specials \
          --delete --ignore-errors \
          "$HOST_TARGETS/$target/" "$MER_TARGETS/$target"
}

# create a unique device-id for the target
target_uuidgen() {
    local mytarget=$1

    if [[ -z $mytarget ]]; then
	echo >&2 "NOTICE: target_uuidgen: empty target name given"
	return 0
    fi

    echo >&2 "target_uuidgen: generating a unique id for target '$mytarget'"
    sb2 -t "$mytarget" -m sdk-install -R rm -f /var/lib/dbus/machine-id || return
    sb2 -t "$mytarget" -m sdk-install -R dbus-uuidgen --ensure
}

# add the MerSDK hostname to target's /etc/hosts
amend_target_hosts() {
    local mytarget=$1
    local myhostname=$(hostname)

    if [[ -z $mytarget ]]; then
	echo >&2 "NOTICE: amend_target_hosts: empty target name given"
	return 0
    fi

    sb2 -t "$mytarget" -m sdk-install -R sed -i "s,\(127.0.0.1.*\),\1 $myhostname," /etc/hosts
}

# Download and install a rootfs
install_target() {
    local skip_toolchain_check=0
    if [[ $1 == "--jfdi" ]]; then
	# Sometimes you want to install without checking the toolchain - jfdi
        skip_toolchain_check=1
        shift
    fi

    local target=$1 toolchain=$2 url=$3

    if [[ $(get_targets) =~ $(echo "\<$target\>") ]]; then
        echo >&2 "Target already exists '$target'"
        return 1
    fi

    if ! [[ $skip_toolchain_check ]]; then
	echo >&2 "Making sure the right toolchain exists"
        if ! ensure_installed "$toolchain"; then
            echo >&2 "Installing required toolchain '$toolchain'"
            install_toolchain "$toolchain" || return
        fi
    fi

    # make sure the target dir exists
    if [[ ! -d $MER_TARGETS ]]; then
        sudo mkdir -p "$(dirname "$MER_TARGETS")" || return
        sudo install -d -o $(id -u) -g $(id -g) "$MER_TARGETS" || return
    fi

    local download_result= local_file= downloaded=

    local succeeded=
    install_target_cleanup() (
        trap 'echo cleaning up...' INT TERM HUP
        if [[ $download_result ]]; then
            local local_file= downloaded=
            if unpack "$download_result" local_file downloaded && [[ $downloaded ]]; then
                rm -f "$local_file"
            fi
        fi
        if [[ ! $succeeded ]]; then
            rm -rf "$SBOX2DIR/$target"
            sudo rm -rf "$MER_TARGETS/$target"
            if [[ $INSIDE_VBOX ]]; then
                rm -rf "$HOST_TARGETS/$target"
            fi
        fi
    )
    trap 'install_target_cleanup; trap - RETURN' RETURN
    trap 'return 1' INT TERM HUP

    download_result=$(download "$url" "$MER_TARGETS" "$target.tar.bz2") || return
    unpack "$download_result" local_file downloaded

    # Virtualbox shared folders don't work too well at the moment
    # Unpack targets to a private area within the VM
    sudo rm -rf "$MER_TARGETS/$target" || return
    sudo mkdir -p "$MER_TARGETS/$target" || return

    # only create HOST_TARGETS dirs if inside the VM
    if [[ $INSIDE_VBOX ]]; then
        mkdir -p "$HOST_TARGETS/$target" || return
    fi

    echo >&2
    echo >&2 "Unpacking target ..."
    if ! sudo tar -C "$MER_TARGETS/$target" -xf "$local_file"; then
        if [[ $( df --sync "$MER_TARGETS" | tr -s ' ' | tail -n 1 | cut -d ' ' -f 4 ) -lt 10000 ]]; then
	    echo >&2 "Not enough disk space to unpack target image"
	else
	    echo >&2 "Could not unpack target image"
	fi
        return 1
    fi

    sudo chown -R $(id -u):$(id -g) "$MER_TARGETS/$target" || return

    if [[ $INSIDE_VBOX ]]; then
        synchronise_target "$target"
        [[ $? -ne 0 ]] && echo >&2 "Rsync did not exactly run as intended, expect problems."
    fi

    echo >&2 "Setting up SB2"

    local transparency= compiler= toolsdir=
    case $toolchain in
	*-arm*)
            local architecture=${toolchain##*-}
            transparency="/usr/bin/qemu-arm-dynamic"
	    compiler="/opt/cross/bin/$architecture-meego-linux-gnueabi-gcc"
            toolsdir="/"
	    ;;
	*-mipsel)
            transparency="/usr/bin/qemu-mipsel-dynamic"
	    compiler="/opt/cross/bin/mipsel-meego-linux-gnu-gcc"
            toolsdir="/"
	    ;;
	*-i486*)
	    compiler="/opt/cross/bin/i486-meego-linux-gnu-gcc"
	    ;;
    esac

    if [[ $INSIDE_CHROOT ]]; then
        getent passwd $(id -u) |sudo tee -a "$MER_TARGETS/$target/etc/passwd" >/dev/null
        getent group $(id -u) |sudo tee -a "$MER_TARGETS/$target/etc/group" >/dev/null
    fi

    (
        cd "$MER_TARGETS/$target" && sb2-init \
            -L "--sysroot=/" -C "--sysroot=/" ${transparency:+-c "$transparency"} \
            -m sdk-build -n -N ${toolsdir:+-t "$toolsdir"} "$target" "$compiler"
    ) || return

    # make sure the created target gets a unique id
    target_uuidgen "$target" || return

    # fix target's /etc/hosts
    amend_target_hosts "$target" || return

    assert_target_and_setup "$target" || return

    if [[ $INSIDE_VBOX ]]; then
	echo >&2 "Notifying Qt Creator of new target"
        updateQtCreatorTargets --name "$target" --target-xml "$TARGETS_XML" || return
    fi

    echo >&2 "Target '$target' now setup"
    succeeded=1
}

remove_target() {
    local target=$1
    if [[ -d $SBOX2DIR/$target ]]; then
        rm -r "$SBOX2DIR/$target"
        sudo rm -rf "$MER_TARGETS/$target"
	if [[ $INSIDE_VBOX ]]; then
            rm -rf "$HOST_TARGETS/$target"
	    echo >&2 "Notifying Qt Creator of removed target"
	fi
    else
        echo >&2 "Note: target '$target' was not seen by sb2"
    fi

    if [[ $INSIDE_VBOX ]]; then
        # Notify Qt Creator always when we're in the VM to keep the
        # target information in sync
        updateQtCreatorTargets --delete --name "$target" --target-xml "$TARGETS_XML" || return
    fi
}

manage_targets() {
    if ! [[ ${1:-} ]]; then
        usage
        return 1
    fi

    case $1 in
	--list )
	    get_targets
	    ;;
	--upgradable ) shift
            local target=${1:-}
            assert_target_and_setup "$target" || return
            t_zypper "$target" --non-interactive --no-refresh --quiet list-updates
	    ;;
	--install ) shift
            assert_target_name_valid "${1:-}" || return
            install_target "$@"
	    ;;
	--remove ) shift
            assert_target_name_valid "${1:-}" || return
	    remove_target "$@"
	    ;;
	--refresh ) shift
            local targets=
            if [[ ${1:-} == "--all" ]]; then
                targets=($(get_targets)) || return
	    else
                targets=("$@")
	    fi
            local target=
            for target in "${targets[@]}"; do
                assert_target_and_setup || return
                t_zypper "$target" --non-interactive refresh || return
	    done
	    ;;
	--update ) shift
            local target=${1:-}
            assert_target_and_setup || return
            t_zypper "$target" --non-interactive dup
	    ;;
	--sync ) shift
            local target=${1:-}
            assert_target_name_valid "$target" || return
	    if [[ ! $INSIDE_VBOX ]]; then
	        echo >&2 "This operation is only valid for SDK in VirtualBox"
                return 1
	    fi
            synchronise_target "$@" || return
            updateQtCreatorTargets --name "$target" --target-xml "$TARGETS_XML"
	    ;;
	--import ) shift
            assert_target_name_valid "${1:-}" || return
	    if [[ ! $INSIDE_VBOX ]]; then
	        echo >&2 "This operation is only valid for SDK in VirtualBox"
                return 1
	    fi
	    import_target "$@"
	    ;;
	--register ) shift
            local credentials= username= password= reg_shift=
            credentials=$(get_register_credentials "$@") || return
            unpack "$credentials" username password reg_shift
	    shift $reg_shift

            local targets= target= alltargets=
            if [[ ${1:-} == "--all" ]]; then
                targets=($(get_targets)) || return
		alltargets=1
		shift
	    else
                targets=("$@")
                for target in "${targets[@]}"; do
                    assert_target_and_setup "$target" || return
                done
	    fi

	    # Fail here if --all was not used and no targets were given
            [[ $targets || $alltargets ]] || { usage; return 1; }

            for target in "${targets[@]}"; do
                t_register "$target" "$username" "$password" || return
	    done
	    ;;
	* )
            echo >&2 "unrecognized option '$1'"
            usage
            return 1
	    ;;
    esac
}

################################################################
# SDK

get_sdk_version() {
    echo "Version not available"
}

upgrade_sdk() {
    sudo zypper --quiet --non-interactive refresh -f || return
    sudo zypper --quiet --non-interactive dup
}

refresh_sdk() {
    sudo zypper --quiet --non-interactive refresh -f
}

register_sdk() {
    local credentials= username= password=
    credentials=$(get_register_credentials "$@") || return
    unpack "$credentials" username password

    local domain=$(sdk-register -d)
    if [[ $domain != jolla ]]; then
	echo >&2 "MerSDK: Register not needed (domain: ${domain:-empty})"
        return
    fi

    echo >&2 -n "MerSDK: "
    sdk-register -u "$username" -p "$password"
}

sdk_status() {
    local err=0
    sdk_vbox_status || err=1
    return $err
}

sdk_vbox_status() {
    [[ $INSIDE_VBOX ]] || return 0
    local err=0

    systemctl --failed || err=1

    if ! sudo VBoxControl -nologo sharedfolder list | grep -q ' home$'; then
	echo "'home' shared folder is missing"
        err=1
    fi
    if ! sudo VBoxControl -nologo sharedfolder list | grep -q ' config$'; then
	echo "'config' shared folder is missing"
        err=1
    fi
    if ! sudo VBoxControl -nologo sharedfolder list | grep -q ' targets$'; then
	echo "'targets' shared folder is missing"
        err=1
    fi

    return $err
}

manage_sdk() {
    if ! [[ ${1:-} ]]; then
        usage
        return 1
    fi

    case $1 in
	--version )
	    get_sdk_version
	    ;;
	--status )
	    sdk_status
	    ;;
	--upgradable ) shift
	    zypper --non-interactive --no-refresh --quiet list-updates
	    ;;
	--upgrade ) shift
	    upgrade_sdk "$@"
	    ;;
	--refresh )
	    refresh_sdk
	    ;;
	--register ) shift
	    # expects --user and --password
	    register_sdk "$@"
	    ;;
	* )
            echo >&2 "unrecognized option '$1'"
            usage
            return 1
	    ;;
    esac
}

################################################################
# utility

get_register_credentials() {
    local username= password= shift=0

    while [[ ${1:-} ]]; do
        case $1 in
	    --user )
                [[ -n ${2:-} ]] || { usage; return 1; }
                username=$2
                let shift+=2
                shift 2
		;;
	    --password )
                [[ -n ${2:-} ]] || { usage; return 1; }
                password=$2
                let shift+=2
                shift 2
		;;
	    *)
		break
		;;
	esac
    done

    if [[ -z $username || -z $password ]]; then
        echo >&2 "Missing --user and/or --password option"
        usage
        return 1
    fi

    print_array "$username" "$password" "$shift"
}

################

INSIDE_CHROOT=$([[ -e /etc/mer-sdk-chroot ]] && echo 1)
INSIDE_VBOX=$([[ -e /etc/mer-sdk-vbox ]] && echo 1)

# exactly one must be true
if [[ $INSIDE_CHROOT$INSIDE_VBOX != 1 ]]; then
    echo >&2 "Internal error: Failed to determine type of SDK installation"
    exit 1
fi

MER_TARGETS=/srv/mer/targets
HOST_TARGETS=/host_targets
SBOX2DIR=${HOME}/.scratchbox2
TARGETS_XML=${HOST_TARGETS}/targets.xml

################################################################
# Main

if [[ ${SDK_MANAGE_DEBUG:-} ]]; then
    sdk_manage_global_vars=
    sdk_manage_global_vars=$(compgen -v)
    check_leaked_local_vars() {
        local current=$(compgen -v)
        local ignored=(-e 'FUNCNAME' -e 'BASH_.*')
        current=$(grep -v --line-regexp "${ignored[@]}" <<<"$current")
        local leaked=$(join -v 2 <(echo "$sdk_manage_global_vars") <(echo "$current"))
        if [[ $leaked ]]; then
            echo >&2 "DEBUG: These variables should be declared local to the functions they originated from: $leaked"
        else
            echo >&2 "DEBUG: No local variable leaked"
        fi
    }
    trap check_leaked_local_vars EXIT
fi

if ! [[ ${1:-} ]]; then
    usage
    exit 1
fi

case $1 in
    --toolchain ) shift
	manage_toolchains "$@"
	;;
    --target ) shift
	manage_targets "$@"
	;;
    --devel ) shift
	manage_develpkgs "$@"
	;;
    --sdk ) shift
	manage_sdk "$@"
	;;
    --refresh-all ) shift
        manage_targets --refresh --all || exit
	manage_sdk --refresh
	;;
    --register-all ) shift
	# expects to get --user and --password too
        manage_sdk --register "$@" || exit
	manage_targets --register "$@" --all
	;;
    --version)
	echo "$0, version VERSION_FROM_SPEC"
	exit 0
	;;
    -h|--help)
        usage 2>&1
        exit 0
        ;;
    * )
        echo >&2 "unrecognized option '$1'"
        usage
        exit 1
	;;
esac
